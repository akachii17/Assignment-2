{
  "version": 3,
  "sources": ["../../three/examples/jsm/curves/NURBSCurve.js"],
  "sourcesContent": ["import {\n\tCurve,\n\tVector3,\n\tVector4\n} from 'three';\nimport * as NURBSUtils from '../curves/NURBSUtils.js';\n\n/**\n * NURBS curve object\n *\n * Derives from Curve, overriding getPoint and getTangent.\n *\n * Implementation is based on (x, y [, z=0 [, w=1]]) control points with w=weight.\n *\n **/\n\nclass NURBSCurve extends Curve {\n\n\tconstructor(\n\t\tdegree,\n\t\tknots /* array of reals */,\n\t\tcontrolPoints /* array of Vector(2|3|4) */,\n\t\tstartKnot /* index in knots */,\n\t\tendKnot /* index in knots */\n\t) {\n\n\t\tsuper();\n\n\t\tthis.degree = degree;\n\t\tthis.knots = knots;\n\t\tthis.controlPoints = [];\n\t\t// Used by periodic NURBS to remove hidden spans\n\t\tthis.startKnot = startKnot || 0;\n\t\tthis.endKnot = endKnot || ( this.knots.length - 1 );\n\n\t\tfor ( let i = 0; i < controlPoints.length; ++ i ) {\n\n\t\t\t// ensure Vector4 for control points\n\t\t\tconst point = controlPoints[ i ];\n\t\t\tthis.controlPoints[ i ] = new Vector4( point.x, point.y, point.z, point.w );\n\n\t\t}\n\n\t}\n\n\tgetPoint( t, optionalTarget = new Vector3() ) {\n\n\t\tconst point = optionalTarget;\n\n\t\tconst u = this.knots[ this.startKnot ] + t * ( this.knots[ this.endKnot ] - this.knots[ this.startKnot ] ); // linear mapping t->u\n\n\t\t// following results in (wx, wy, wz, w) homogeneous point\n\t\tconst hpoint = NURBSUtils.calcBSplinePoint( this.degree, this.knots, this.controlPoints, u );\n\n\t\tif ( hpoint.w !== 1.0 ) {\n\n\t\t\t// project to 3D space: (wx, wy, wz, w) -> (x, y, z, 1)\n\t\t\thpoint.divideScalar( hpoint.w );\n\n\t\t}\n\n\t\treturn point.set( hpoint.x, hpoint.y, hpoint.z );\n\n\t}\n\n\tgetTangent( t, optionalTarget = new Vector3() ) {\n\n\t\tconst tangent = optionalTarget;\n\n\t\tconst u = this.knots[ 0 ] + t * ( this.knots[ this.knots.length - 1 ] - this.knots[ 0 ] );\n\t\tconst ders = NURBSUtils.calcNURBSDerivatives( this.degree, this.knots, this.controlPoints, u, 1 );\n\t\ttangent.copy( ders[ 1 ] ).normalize();\n\n\t\treturn tangent;\n\n\t}\n\n}\n\nexport { NURBSCurve };\n"],
  "mappings": ";;;;;;;;;;;;AAgBA,IAAM,aAAN,cAAyB,MAAM;AAAA,EAE9B,YACC,QACA,OACA,eACA,WACA,SACC;AAED,UAAM;AAEN,SAAK,SAAS;AACd,SAAK,QAAQ;AACb,SAAK,gBAAgB,CAAC;AAEtB,SAAK,YAAY,aAAa;AAC9B,SAAK,UAAU,WAAa,KAAK,MAAM,SAAS;AAEhD,aAAU,IAAI,GAAG,IAAI,cAAc,QAAQ,EAAG,GAAI;AAGjD,YAAM,QAAQ,cAAe,CAAE;AAC/B,WAAK,cAAe,CAAE,IAAI,IAAI,QAAS,MAAM,GAAG,MAAM,GAAG,MAAM,GAAG,MAAM,CAAE;AAAA,IAE3E;AAAA,EAED;AAAA,EAEA,SAAU,GAAG,iBAAiB,IAAI,QAAQ,GAAI;AAE7C,UAAM,QAAQ;AAEd,UAAM,IAAI,KAAK,MAAO,KAAK,SAAU,IAAI,KAAM,KAAK,MAAO,KAAK,OAAQ,IAAI,KAAK,MAAO,KAAK,SAAU;AAGvG,UAAM,SAAoB,iBAAkB,KAAK,QAAQ,KAAK,OAAO,KAAK,eAAe,CAAE;AAE3F,QAAK,OAAO,MAAM,GAAM;AAGvB,aAAO,aAAc,OAAO,CAAE;AAAA,IAE/B;AAEA,WAAO,MAAM,IAAK,OAAO,GAAG,OAAO,GAAG,OAAO,CAAE;AAAA,EAEhD;AAAA,EAEA,WAAY,GAAG,iBAAiB,IAAI,QAAQ,GAAI;AAE/C,UAAM,UAAU;AAEhB,UAAM,IAAI,KAAK,MAAO,CAAE,IAAI,KAAM,KAAK,MAAO,KAAK,MAAM,SAAS,CAAE,IAAI,KAAK,MAAO,CAAE;AACtF,UAAM,OAAkB,qBAAsB,KAAK,QAAQ,KAAK,OAAO,KAAK,eAAe,GAAG,CAAE;AAChG,YAAQ,KAAM,KAAM,CAAE,CAAE,EAAE,UAAU;AAEpC,WAAO;AAAA,EAER;AAED;",
  "names": []
}
